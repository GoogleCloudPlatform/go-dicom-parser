// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package main generates a list of tags from the DICOM data dictionary
package main

import (
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"time"

	"flag"
	
)

const (
	dictionaryXML                     = "http://dicom.nema.org/medical/dicom/current/source/docbook/part06/part06.xml"
	version                           = "DICOM PS3.6 2018b"
	elementsLabel                     = "6"
	metaElementsLabel                 = "7"
	directoryStructuringElementsLabel = "8"
)

var (
	outputFilename   = flag.String("output_filename", "", "file to output tags")
	tagsFileTemplate = template.Must(template.New("").Parse(
		`// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dicom
// Code generated by generatetags.go; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from
// {{ .URL }}

const (
{{- range .Tags }}
	{{ printf "// %vTag is the data element tag of %v" .Keyword .Keyword}}
	{{ printf "%vTag = 0x%08X\n" .Keyword .TagID }}
{{- end }}
)

// Tags in the DICOM data dictionary have wildcards (e.g. tags like (gggg,eexx), (ggxx,eeee))
// The tag library stores the value of the tag with the x's set to '0' in hex.
// For example the Curve Data tag is defined as (50xx,3000). The variable
// CurveDataTag = 0x50003000. So we can check if a given tag is of the form (50xx,3000) from
// the condition (tag &^ 0x00FF0000) == CurveDataTag.  The following is an exhaustive list
// of all masks required for wildcards in the DICOM data dictionary. The value 0 is 
// included at the beginning for convenience since (tag &^ 0) == tag.
var vrWildcardMasks = []uint32{
	{{- range .BitMasks }}
		{{ printf "0x%08X," . }}
	{{- end }}
}

var singleValueTagVRMap = map[DataElementTag]string {
	{{- range .SingleValueTags }}
		{{ printf "%vTag: \"%v\"," .Keyword .VR }}
	{{- end }}
}

var wildcardTagVRMap = map[DataElementTag]string {
	{{- range .RangeBasedTags }}
		{{ printf "%vTag: \"%v\"," .Keyword .VR }}
	{{- end }}
		}
`))
)

// DocBook XML struct, with tags related to DICOM data dictionary information.
type DocBook struct {
	Version  string `xml:"subtitle"`
	Chapters []struct {
		Label string `xml:"label,attr"`
		Title string `xml:"title"`
		Rows  []struct {
			Data []struct {
				CharData string `xml:",chardata"`
				Text     string `xml:",any"`
			} `xml:"td>para"`
		} `xml:"table>tbody>tr"`
	} `xml:"chapter"`
}

type dataElementTag struct {
	TagID   uint32
	BitMask uint32
	Name    string
	Keyword string
	VR      string
	VM      string
	Retired bool
}

func (t dataElementTag) String() string {
	return fmt.Sprintf("0x%08x %v", t.TagID, t.Keyword)
}

func (t dataElementTag) IsRepeatingGroup() bool {
	return t.BitMask != 0
}

// For elements part of repeating groups like (ggxx,eeee), return a bitmask `m` such that
// (tag &^ m) sets the x's to 0's. For the non-repeating group case, the mask is simply 0
func createBitMask(ggggeeee string) (uint32, error) {
	s := ""
	for _, c := range ggggeeee {
		if c == 'x' {
			s += "F"
		} else {
			s += "0"
		}
	}
	mask, err := strconv.ParseUint(s, 16, 32)

	return uint32(mask), err
}

func readDataElementFromRow(s []string) dataElementTag {
	var tag dataElementTag

	// DICOM data element row contains data in the following order:
	// Tag, Name, Keyword, VR, VM, Note (including whether the tag is retired).
	if len(s) != 6 {
		log.Fatalf("Missing data elements for row: %v", s)
	}
	// Read DICOM data element tag of the form "(gggg,eeee)".
	ggggeeee := s[0][1:5] + s[0][6:10]
	if strings.Contains(ggggeeee, "x") {
		// Handle repeated group or element numbers, indicated by "x" in the tag.
		if tagStart, err := strconv.ParseUint(strings.Replace(ggggeeee, "x", "0", -1), 16, 32); err != nil {
			log.Fatalf("Format error on repeated tag number for row %v, error: %v", s, err)
		} else {
			tag.TagID = uint32(tagStart)
		}
	} else {
		tagNum, _ := strconv.ParseUint(ggggeeee, 16, 32)
		tag.TagID = uint32(tagNum)
	}

	if bitMask, err := createBitMask(ggggeeee); err != nil {
		log.Fatalf("Format error on repeated tag number for row %v, error: %v", s, err)
	} else {
		tag.BitMask = bitMask
	}

	tag.Name = s[1]
	// Strip zero-width spaces from Keyword field.
	tag.Keyword = strings.Replace(s[2], "\u200B", "", -1)
	tag.VR = s[3]
	tag.VM = s[4]
	tag.Retired = s[5] == "RET"

	return tag
}

func filterTags(tags []dataElementTag) []dataElementTag {
	filteredTags := make([]dataElementTag, 0)
	for _, tag := range tags {
		vrs := strings.Split(tag.VR, " or ")
		if len(vrs) == 0 {
			log.Fatalf("no VR for tag %v found", tag)
		}
		// TODO current parser behaviour relies on choosing the last VR from the standard
		tag.VR = vrs[len(vrs)-1]

		if len(tag.Keyword) == 0 {
			fmt.Println("skipping tag without keyword: ", tag)
			continue
		}

		groupNumber := tag.TagID >> 16
		if groupNumber == 0xFFFE {
			tag.VR = "" // sequence VRs will have empty VR name
		}
		filteredTags = append(filteredTags, tag)
	}

	return filteredTags
}

func generateBitMasks(tags []dataElementTag) []uint32 {
	bitMaskSet := map[uint32]bool{}
	for _, tag := range tags {
		bitMaskSet[tag.BitMask] = true
	}
	bitMasks := make([]uint32, 0)
	for mask := range bitMaskSet {
		bitMasks = append(bitMasks, mask)
	}

	// make sure 0 is at the beginning to allow exact matches to be prioritized
	sort.Slice(bitMasks, func(i, j int) bool {
		return bitMasks[i] < bitMasks[j]
	})

	return bitMasks
}

func generateCode(tags []dataElementTag) {
	sort.Slice(tags, func(i, j int) bool {
		return tags[i].TagID < tags[j].TagID
	})

	filteredTags := filterTags(tags)

	// The range-based tags are separated from the non-range based tags to eliminate duplicate keys in
	// the generated map
	rangeBasedTags := make([]dataElementTag, 0)
	singleValueTags := make([]dataElementTag, 0)
	for _, tag := range filteredTags {
		if tag.IsRepeatingGroup() {
			rangeBasedTags = append(rangeBasedTags, tag)
		} else {
			singleValueTags = append(singleValueTags, tag)
		}
	}

	f, err := os.Create(*outputFilename)
	if err != nil {
		log.Fatalf("os.Create(%v) => %v", *outputFilename, err)
	}

	tagsFileTemplate.Execute(f, struct {
		Timestamp       time.Time
		URL             string
		BitMasks        []uint32
		RangeBasedTags  []dataElementTag
		SingleValueTags []dataElementTag
		Tags            []dataElementTag
	}{
		Timestamp:       time.Now(),
		URL:             dictionaryXML,
		BitMasks:        generateBitMasks(filteredTags),
		RangeBasedTags:  rangeBasedTags,
		SingleValueTags: singleValueTags,
		Tags:            filteredTags,
	})
}

func main() {
	flag.Parse()

	// Read XML document from given URL and marshal DICOM dictionary data.
	r, err := http.Get(dictionaryXML)
	if err != nil {
		log.Fatalf("Unable to retrieve data dictionary URL, error: %v", err)
	}

	b := r.Body
	defer b.Close()

	buf, err := ioutil.ReadAll(b)
	if err != nil {
		log.Fatalf("Unable to load data dictionary file, eroror: %v", err)
	}

	var dict DocBook
	if err := xml.Unmarshal(buf, &dict); err != nil {
		log.Fatalf("Unable to Unmarshal data dictionary file, error: %v", err)
	}

	// Verify that document version match expected value.
	if !strings.HasPrefix(dict.Version, version) {
		log.Fatalf("Version mismatch: %v, expected %v", dict.Version, version)
	}

	tags := make([]dataElementTag, 0)
	for _, c := range dict.Chapters {
		if c.Label == elementsLabel || c.Label == metaElementsLabel || c.Label == directoryStructuringElementsLabel {
			for _, r := range c.Rows {
				t := []string{}
				for _, d := range r.Data {
					// Individual table cells will either be plain chardata or contained
					// inside a formatting tag.
					t = append(t, strings.TrimSpace(d.CharData)+strings.TrimSpace(d.Text))
				}
				tag := readDataElementFromRow(t)
				tags = append(tags, tag)
			}
		}
	}
	generateCode(tags)
}
