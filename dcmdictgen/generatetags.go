// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package main generates a list of tags from the DICOM data dictionary
package main

import (
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"time"

	"flag"
	
)

const (
	dictionaryXML                     = "http://dicom.nema.org/medical/dicom/current/source/docbook/part06/part06.xml"
	version                           = "DICOM PS3.6 2018b"
	elementsLabel                     = "6"
	metaElementsLabel                 = "7"
	directoryStructuringElementsLabel = "8"
)

var (
	outputFilename   = flag.String("output_filename", "", "file to output tags")
	tagsFileTemplate = template.Must(template.New("").Parse(
		`package dicom
// Code generated by generatetags.go; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from
// {{ .URL }}

const (
{{- range .Tags }}
	{{ printf "// %vTag is the data element tag of %v" .Keyword .Keyword}}
	{{ printf "%vTag = 0x%08X\n" .Keyword .TagID }}
{{- end }}
)

var singleValueTagVRMap = map[DataElementTag]string {
	{{- range .SingleValueTags }}
		{{ printf "%vTag: \"%v\"," .Keyword .VR }}
	{{- end }}
}

var wildcardTagVRMap = map[DataElementTag]string {
	{{- range .RangeBasedTags }}
		{{ printf "%vTag: \"%v\"," .Keyword .VR }}
	{{- end }}
		}
`))
)

// DocBook XML struct, with tags related to DICOM data dictionary information.
type DocBook struct {
	Version  string `xml:"subtitle"`
	Chapters []struct {
		Label string `xml:"label,attr"`
		Title string `xml:"title"`
		Rows  []struct {
			Data []struct {
				CharData string `xml:",chardata"`
				Text     string `xml:",any"`
			} `xml:"td>para"`
		} `xml:"table>tbody>tr"`
	} `xml:"chapter"`
}

type tagRange struct {
	TagIncrement uint32
	tagFinalID   uint32
}

type dataElementTag struct {
	TagID   uint32
	Name    string
	Keyword string
	VR      string
	VM      string
	Retired bool
	Range   *tagRange
}

func (t dataElementTag) String() string {
	return fmt.Sprintf("0x%08x %v", t.TagID, t.Keyword)
}

func readDataElementFromRow(s []string) dataElementTag {
	var tag dataElementTag

	// DICOM data element row contains data in the following order:
	// Tag, Name, Keyword, VR, VM, Note (including whether the tag is retired).
	if len(s) != 6 {
		log.Fatalf("Missing data elements for row: %v", s)
	}
	// Read DICOM data element tag of the form "(gggg,eeee)".
	ge := s[0][1:5] + s[0][6:10]
	if strings.Contains(ge, "x") {
		// Handle repeated group or element numbers, indicated by "x" in the tag.
		tag.Range = &tagRange{}
		if tagStart, err := strconv.ParseUint(strings.Replace(ge, "x", "0", -1), 16, 32); err != nil {
			log.Fatalf("Format error on repeated tag number for row %v, error: %v", s, err)
		} else {
			tag.TagID = uint32(tagStart)
		}
		if tagFinal, err := strconv.ParseUint(strings.Replace(ge, "x", "F", -1), 16, 32); err != nil {
			log.Fatalf("Format error on repeated tag number for row %v, error: %v", s, err)
		} else {
			tag.Range.tagFinalID = uint32(tagFinal)
		}
		// Count the number of hex digits between the final "x" and the end of the
		// tag range description. The increment will be Pow(16, index).
		index := (uint)(7 - strings.LastIndex(ge, "x"))
		tag.Range.TagIncrement = 1 << (4 * index)
		if index == 4 {
			// The exception to this is if the lowest order bit of the group number is
			// part of the range, as public group numbers must be even.
			tag.Range.TagIncrement = tag.Range.TagIncrement * 2
		}
	} else {
		tagNum, _ := strconv.ParseUint(ge, 16, 32)
		tag.TagID = uint32(tagNum)
	}

	tag.Name = s[1]
	// Strip zero-width spaces from Keyword field.
	tag.Keyword = strings.Replace(s[2], "\u200B", "", -1)
	tag.VR = s[3]
	tag.VM = s[4]
	tag.Retired = s[5] == "RET"

	return tag
}

func filterTags(tags []dataElementTag) []dataElementTag {
	filteredTags := make([]dataElementTag, 0)
	for _, tag := range tags {
		vrs := strings.Split(tag.VR, " or ")
		if len(vrs) == 0 {
			log.Fatalf("no VR for tag %v found", tag)
		}
		// TODO current parser behaviour relies on choosing the last VR from the standard
		tag.VR = vrs[len(vrs)-1]

		if len(tag.Keyword) == 0 {
			fmt.Println("skipping tag without keyword: ", tag)
			continue
		}

		groupNumber := tag.TagID >> 16
		if groupNumber == 0xFFFE {
			tag.VR = "" // sequence VRs will have empty VR name
		}
		filteredTags = append(filteredTags, tag)
	}

	return filteredTags
}

func generateCode(tags []dataElementTag) {
	sort.Slice(tags, func(i, j int) bool {
		return tags[i].TagID < tags[j].TagID
	})

	filteredTags := filterTags(tags)

	rangeBasedTags := make([]dataElementTag, 0)
	singleValueTags := make([]dataElementTag, 0)

	for _, tag := range filteredTags {
		if tag.Range != nil {
			rangeBasedTags = append(rangeBasedTags, tag)
		} else {
			singleValueTags = append(singleValueTags, tag)
		}
	}

	f, err := os.Create(*outputFilename)
	if err != nil {
		log.Fatalf("os.Create(%v) => %v", *outputFilename, err)
	}

	tagsFileTemplate.Execute(f, struct {
		Timestamp       time.Time
		URL             string
		RangeBasedTags  []dataElementTag
		SingleValueTags []dataElementTag
		Tags            []dataElementTag
	}{
		Timestamp:       time.Now(),
		URL:             dictionaryXML,
		RangeBasedTags:  rangeBasedTags,
		SingleValueTags: singleValueTags,
		Tags:            filteredTags,
	})
}

func main() {
	flag.Parse()

	// Read XML document from given URL and marshal DICOM dictionary data.
	r, err := http.Get(dictionaryXML)
	if err != nil {
		log.Fatalf("Unable to retrieve data dictionary URL, error: %v", err)
	}

	b := r.Body
	defer b.Close()

	buf, err := ioutil.ReadAll(b)
	if err != nil {
		log.Fatalf("Unable to load data dictionary file, eroror: %v", err)
	}

	var dict DocBook
	if err := xml.Unmarshal(buf, &dict); err != nil {
		log.Fatalf("Unable to Unmarshal data dictionary file, error: %v", err)
	}

	// Verify that document version match expected value.
	if !strings.HasPrefix(dict.Version, version) {
		log.Fatalf("Version mismatch: %v, expected %v", dict.Version, version)
	}

	tags := make([]dataElementTag, 0)
	for _, c := range dict.Chapters {
		if c.Label == elementsLabel || c.Label == metaElementsLabel || c.Label == directoryStructuringElementsLabel {
			for _, r := range c.Rows {
				t := []string{}
				for _, d := range r.Data {
					// Individual table cells will either be plain chardata or contained
					// inside a formatting tag.
					t = append(t, strings.TrimSpace(d.CharData)+strings.TrimSpace(d.Text))
				}
				tag := readDataElementFromRow(t)
				tags = append(tags, tag)
			}
		}
	}
	generateCode(tags)
}
